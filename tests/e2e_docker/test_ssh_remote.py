"""E2E tests for SSH remote operations.

Tests the -r/--remote flag with real SSH connections between Docker containers.
"""

import pytest
from conftest import run_cli, ssh_run

pytestmark = pytest.mark.e2e_docker


class TestSSHConnectivity:
    """Test basic SSH connectivity between containers."""

    def test_ssh_to_node_alpha(self, verify_ssh_connectivity):
        """Can SSH to node-alpha."""
        result = ssh_run("alice", "node-alpha", "whoami")
        assert result.returncode == 0
        assert "alice" in result.stdout

    def test_ssh_to_node_beta(self, verify_ssh_connectivity):
        """Can SSH to node-beta."""
        result = ssh_run("charlie", "node-beta", "whoami")
        assert result.returncode == 0
        assert "charlie" in result.stdout

    def test_ssh_batch_mode(self, verify_ssh_connectivity):
        """SSH works with BatchMode=yes (no password prompts)."""
        result = ssh_run("alice", "node-alpha", "echo batch-ok")
        assert result.returncode == 0
        assert "batch-ok" in result.stdout


class TestRemoteLsw:
    """Test lsw (list workspaces) with remote flag."""

    def test_lsw_remote_lists_workspaces(self, charlie, verify_ssh_connectivity):
        """lsw -r lists workspaces on remote node."""
        result = run_cli(["lsw", "-r", charlie])
        assert result.returncode == 0, f"stderr: {result.stderr}"
        # Should see charlie's workspaces
        assert "myproject" in result.stdout or "another-project" in result.stdout

    def test_lsw_remote_different_users(self, alice, charlie, verify_ssh_connectivity):
        """Different users on different nodes have different workspaces."""
        alice_result = run_cli(["lsw", "-r", alice])
        charlie_result = run_cli(["lsw", "-r", charlie])

        assert alice_result.returncode == 0
        assert charlie_result.returncode == 0

        # Both should have workspaces (generated by setup script)
        assert alice_result.stdout.strip() != ""
        assert charlie_result.stdout.strip() != ""

    def test_lsw_remote_with_pattern(self, charlie, verify_ssh_connectivity):
        """lsw -r with pattern filters workspaces."""
        result = run_cli(["lsw", "myproject", "-r", charlie])
        assert result.returncode == 0
        # Should match myproject
        if result.stdout.strip():
            assert "myproject" in result.stdout


class TestRemoteLss:
    """Test lss (list sessions) with remote flag."""

    def test_lss_remote_lists_sessions(self, charlie, verify_ssh_connectivity):
        """lss -r lists sessions on remote node."""
        result = run_cli(["lss", "-r", charlie])
        assert result.returncode == 0, f"stderr: {result.stderr}"
        # Should see session information
        # Output format includes file paths and timestamps

    def test_lss_remote_with_workspace(self, charlie, verify_ssh_connectivity):
        """lss workspace -r lists sessions for specific workspace."""
        result = run_cli(["lss", "myproject", "-r", charlie])
        assert result.returncode == 0, f"stderr: {result.stderr}"

    def test_lss_remote_with_date_filter(self, charlie, verify_ssh_connectivity):
        """lss -r with date filter works."""
        result = run_cli(["lss", "--since", "2025-01-01", "-r", charlie])
        assert result.returncode == 0, f"stderr: {result.stderr}"


class TestRemoteExport:
    """Test export with remote flag."""

    def test_export_remote_creates_files(self, charlie, tmp_path, verify_ssh_connectivity):
        """export -r downloads and converts sessions to markdown."""
        output_dir = tmp_path / "export"
        result = run_cli(
            [
                "export",
                "myproject",
                "-r",
                charlie,
                "-o",
                str(output_dir),
            ]
        )
        assert result.returncode == 0, f"stderr: {result.stderr}"
        # Verify output directory was created (may or may not have files)
        assert output_dir.exists()

    def test_export_remote_with_minimal(self, charlie, tmp_path, verify_ssh_connectivity):
        """export -r --minimal produces minimal output."""
        output_dir = tmp_path / "export-minimal"
        result = run_cli(
            [
                "export",
                "myproject",
                "-r",
                charlie,
                "-o",
                str(output_dir),
                "--minimal",
            ]
        )
        assert result.returncode == 0, f"stderr: {result.stderr}"


class TestCrossNodeOperations:
    """Test operations that span multiple nodes."""

    def test_can_reach_both_nodes(self, alice, charlie, verify_ssh_connectivity):
        """Can list workspaces from both nodes."""
        alpha_result = run_cli(["lsw", "-r", alice])
        beta_result = run_cli(["lsw", "-r", charlie])

        assert alpha_result.returncode == 0
        assert beta_result.returncode == 0

    def test_different_node_different_data(self, alice, charlie, verify_ssh_connectivity):
        """Different nodes have different session data."""
        # Alice's sessions
        alice_result = run_cli(["lss", "-r", alice])
        # Charlie's sessions
        charlie_result = run_cli(["lss", "-r", charlie])

        assert alice_result.returncode == 0
        assert charlie_result.returncode == 0

        # The data should be different (different users, different paths)
        # Both generated by setup script but with user-specific paths


class TestRemoteErrors:
    """Test error handling for remote operations."""

    def test_invalid_remote_host(self, verify_ssh_connectivity):
        """Invalid remote host produces error."""
        result = run_cli(["lsw", "-r", "invalid@nonexistent-host"])
        # Should fail (can't connect)
        assert result.returncode != 0 or "error" in result.stderr.lower()

    def test_invalid_remote_user(self, node_alpha, verify_ssh_connectivity):
        """Invalid user on valid host produces error."""
        result = run_cli(["lsw", "-r", f"nonexistent@{node_alpha}"])
        # Should fail (permission denied or user not found)
        assert result.returncode != 0 or "error" in result.stderr.lower()
